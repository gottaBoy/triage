# 候选人面试问题设计

## 候选人背景分析

**技术栈特点**：
- **核心算法**：SLAM（视觉/激光雷达）、计算机视觉（SfM、三维重建）、强化学习（SLAC、端到端自动驾驶）
- **工程落地**：TensorRT 模型部署加速、数据闭环平台搭建、真值系统开发
- **编程语言**：C++（高性能计算）、Python（快速原型与数据处理）
- **教育背景**：宾夕法尼亚大学（机器人顶校）硕士，具备扎实的理论基础

**项目亮点**：
- **安波福（当前）**：基于 SLAC 的端到端自动驾驶系统；城市道路多相机 SfM 三维重建。
- **禾赛科技**：自动化数据处理平台与闭环链路；地库高精度建图与厘米级定位（TensorRT加速）。

---

## 一、端到端自动驾驶与强化学习（25分钟）

### 1. 基于 SLAC 的端到端系统

**问题1.1**：在安波福的项目中，你选择了 SLAC (Stochastic Latent Actor-Critic) 算法。相比于传统的 PPO 或 SAC，为什么选择 SLAC？不仅是“性能更好”，请从**部分可观测性 (Partially Observable)** 和**高维输入**的角度谈谈你的考量。

**追问**：
- 你的“潜在动态模型 (Latent Dynamic Model)”是如何设计的？它预测的是下一时刻的 Latent State 还是 Observation？
- 在强化学习训练中，Reward Function 是如何设计的？如何平衡舒适度（急刹车/急转弯）和通行效率？
- 这个系统目前是在 CARLA 仿真中跑，有没有做 Sim-to-Real 的尝试？如果没有，你认为迁移到真车最大的难点在哪里？

**考察点**：
- 对 SOTA 强化学习算法的深度理解
- 潜在空间建模 (Latent Space Modeling) 能力
- 仿真与现实差距 (Reality Gap) 的认知

**参考答案**：

**问题1.1 参考答案**：
**选择 SLAC 的原因**：
- **处理高维图像**：SLAC 结合了 VAE（用于特征提取）和 RL，适合直接从像素（Pixels）学习策略，而 SAC/PPO 通常需要低维状态输入。
- **部分可观测性 (POMDP)**：自动驾驶是典型的 POMDP 问题（无法看到障碍物背面、无法知晓他车意图）。SLAC 通过维护一个随时间演变的 Latent Variable 序列，实际上编码了历史信息，比单纯的 Frame-stacking 更有效。

**潜在动态模型设计**：
- 通常包含两个部分：
  1.  **Transition Model** (这是关键)：$P(z_{t+1} | z_t, a_t)$，预测下一个潜在状态。
  2.  **Observation Model**：$P(x_t | z_t)$，从潜在状态重建图像（用于辅助训练，保证 $z_t$ 包含有效信息）。
- **Sim-to-Real 难点**：
  - **Visual Gap**：仿真渲染与真实摄像头的纹理、光照差异（可通过 Domain Randomization 缓解）。
  - **Dynamic Gap**：车辆动力学模型（摩擦力、延迟）的不一致。

---

## 二、SLAM 与多传感器融合（30分钟）

### 1. 真值系统与三维重建

**问题2.1**：在开发 LiDAR-IMU 里程计（LIO）作为真值系统时，你采用了什么框架（如 LIO-SAM, FAST-LIO2）？针对**初始化**和**剧烈运动**场景做了哪些优化？

**追问**：
- 真值系统对精度的要求极高。你是如何评估你的轨迹精度的？Ground Truth 的 Ground Truth 是什么？（RTK? 全站仪?）
- 在多相机 SfM 重建中，城市动态场景（行人、车辆）是如何处理的？如果不剔除会产生什么后果？
- 相机和 LiDAR 的**外参标定**是如何做的？是在线标定还是离线标定？

**考察点**：
- SLAM 前端/后端细节
- 动态环境下的鲁棒性设计
- 精度验证方法论

**参考答案**：

**问题2.1 参考答案**：
**LIO 框架与优化**：
- 可能基于 FAST-LIO2（利用 Iterated Kalman Filter 提高效率和精度）或 LIO-SAM（基于因子图优化）。
- **优化点**：
  - **初始化**：静止检测，利用 IMU 重力对齐。
  - **剧烈运动**：增加 IMU 预积分频率，或使用运动约束（Motion Constraints）。

**动态物体处理 (SfM)**：
- **后果**：如果在建图时包含动态物体，会在地图中留下“伪影”（Ghosting），影响重投影误差和后续定位。
- **处理方法**：利用语义分割网络（如 Mask R-CNN）在前端剔除属于“车辆/行人”类别的特征点；或基于几何一致性（RANSAC）剔除运动离群点。

**精度评估**：
- **绝对精度**：对比高精度 RTK-GNSS（在开阔地带）。
- **相对精度**：回到起点计算闭环误差 (Loop Closure Error)。
- **点云重合度**：多次采集同一场景，计算点云配准后的 RMS 误差。

---

## 三、工程落地与数据闭环（25分钟）
*(针对禾赛科技经历)*

### 1. 自动化数据处理平台

**问题3.1**：你提到构建了“自动化数据处理平台”。请介绍一下这个平台的**架构设计**。当每天有 TB 级数据上传时，系统是如何保证高吞吐和稳定性的？

**追问**：
- 这里的“数据质量检查”具体检查什么？（时间戳跳变？丢帧？外参漂移？）如果发现数据异常，链路是如何自动阻断的？
- 怎么理解“数据闭环”？你做的这个平台如何帮助算法迭代？

**考察点**：
- 大规模数据处理架构（如 K8s, Airflow, 消息队列）
- 工程可靠性设计
- 数据闭环的方法论

**参考答案**：

**问题3.1 参考答案**：
**架构设计**：
- **任务调度**：可能使用 Apache Airflow 或 Celery 进行 DAG 任务编排。
- **存储**：对象存储（S3/OSS）存原始数据，数据库（PostgreSQL/MongoDB）存元数据和索引。
- **高吞吐**：利用 K8s 动态扩缩容 Worker 节点；使用消息队列（Kafka/RabbitMQ）解耦采集端和处理端。

**数据质量检查 (Data Hygiene)**：
- **硬件层**：LiDAR/Camera 丢帧率、时间同步误差（PTP/PPS 信号状态）。
- **内容层**：图像过曝/过暗、传感器被遮挡（污渍检测）。
- **逻辑**：一旦检测到 Critical 错误，自动标记为 `invalid`，不进入标注环节，节省成本。

### 2. 模型部署与加速

**问题3.2**：在地库车位识别项目中，你使用了 **TensorRT** 进行加速。请描述一下具体的优化过程。量化（Quantization）时使用了 FP16 还是 INT8？

**追问**：
- 有没有遇到 TensorRT 不支持的算子（Unsupported OPs）？如果有，是怎么解决的？（自定义 Plugin？修改网络结构？）
- 加速后的推理延迟从多少毫秒降低到了多少？对精度（mAP）有多大影响？

**考察点**：
- 深度学习模型部署落地能力
- 性能优化实战经验

**参考答案**：

**问题3.2 参考答案**：
**TensorRT 优化**：
- **精度模式**：通常首选 FP16（精度损失极小，速度提升显著）。INT8 需要 Calibration（校准），实现起来更复杂，但在嵌入式端（Orin/Xavier）很有必要。
- **不支持算子**：
  - 方法一：**自定义 Plugin**（写 CUDA Kernel 实现该算子）。
  - 方法二：**修改网络**（用标准算子组合替代，或换用支持更好的层，例如将 Swish 换成 ReLU，如果影响不大的话）。
- **效果**：通常能获得 2x-5x 的加速比（取决于网络结构和显卡架构）。

---

## 四、基础算法与编程（10分钟）

### 1. C++ 与 数学基础

**问题4.1**：在 SLAM 后端优化中，**卡尔曼滤波 (KF/EKF)** 和 **图优化 (Graph Optimization)** 有什么本质区别？在什么场景下你会优先选择其中一种？

**考察点**：
- SLAM 理论基础
- 计算复杂度与精度的权衡
- 实际场景选型能力

**参考答案**：
- **滤波器 (KF/EKF/MSCKF)**：
  - **机制**：递归估计，只维护当前时刻的状态协方差（Markov 性质）。
  - **优点**：计算量小（且固定），实时性极好，占用内存低。
  - **缺点**：线性化误差容易积累（不可逆），无法像图优化那样对历史轨迹进行反复线性化修正。
  - **适用场景**：资源受限的嵌入式设备（无人机飞控）、需要极高实时反馈的控制回路。
- **图优化 (Factor Graph)**：
  - **机制**：将所有历史状态（或滑动窗口内的状态）作为节点，观测作为边，构建最小二乘问题进行全局/局部优化。
  - **优点**：精度高，利用 Loop Closure 可以消除累积误差（修正历史）。
  - **缺点**：计算量随时间/节点数增长（除非使用 Sliding Window），内存占用大。
  - **适用场景**：高精度建图、自动驾驶定位（通常使用 Sliding Window 优化，如 LIO-SAM/VINS-Mono）。

**问题4.2**：C++ 中 `std::shared_ptr` 和 `std::unique_ptr` 的区别是什么？在多线程环境下使用智能指针需要注意什么？

**考察点**：
- C++ 现代特性
- 内存管理与并发安全

**参考答案**：
- **区别**：`unique_ptr` 独占所有权，开销极小（约等于裸指针），不可复制，只能移动；`shared_ptr` 共享所有权，通过引用计数管理生命周期，开销较大（多一个控制块）。
- **多线程注意**：
  - `shared_ptr` 的**引用计数操作是原子的（线程安全）**。
  - 但 `shared_ptr` **指向的具体对象的操作不是线程安全的**。
  - 如果多个线程同时读写同一个 `shared_ptr` 对象本身（例如改变它指向的对象），也需要加锁。