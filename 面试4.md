实习项目< < <
AMD AI 编译与高性能计算 2025.01-至今
主要职责：
1. 开发模型中间结果比对工具链，实现 CPU 与 NPU 算子级计算差异定位，支撑异构硬件上模型推理精度验证
2. 独立开发 AI 编译器 Profile Pass，新增 DDR Load Size 与 Burst Length 性能属性，通过对内存访问模式的深入分析，实现对
DDR 带宽瓶颈的精准定位，将算子级性能问题的排查效率提升了约 30%，为调度策略提供了核心数据依据
3. 重构 workload_on_arch 计算框架，基于硬件参数优化算子并行逻辑，设计 Kernel Buffer 优化内存访问模式
4. 深度参与编译全流程（Fusion/CostModel/CodeGen/Tiling），独立完成 3D UNet 等模型端到端编译与 NPU 部署，解决算子
适配与精度损失问题，实现 3DUNet 模型量化-编译-NPU 部署全流程自动化
5. 开发 pass_time_profile 模块，量化各编译阶段耗时并生成可视化报告，支撑团队将整体编译耗时缩短 20%
百度 测试开发实习生 2024.05-2025.01
主要指责
1. 负责百度畅听版、百度极速版等核心 App 的 10+次迭代测试，覆盖功能、兼容、稳定性等多维度，确保版本按期高质量上
线。深度参与需求方案评审，结合业务场景提出可测性、风险点与改进建议，推动需求在开发前完成优化
2. 累计设计并执行测试用例 400+条，测试覆盖率达 95%以上，发现并跟踪缺陷 50+，无漏测、无线上事故
3. 熟练运用 Charles 抓包、ADB 日志分析，使用 Jacoco 覆盖率平台，快速识别功能未覆盖代码路径，实现核心模块 100%分
支覆盖基于 iCafe 平台进行需求、缺陷、测试任务的全流程管理，实现“需求-用例-缺陷”双向追溯
北京交通大学实验室项目 2023.10-至今
主要职责
1. 露天煤矿边坡位移预测与预警系统：设计多源时空融合模型，提出预警策略可提前 24 小时触发告警；算法集成于 Flask 后
端开发，使用 clickhouse 数据库，Postman 完成 30+接口测试用例；Git 维护多人协作仓库，PR 合并成功率 100%
技能专长< < <
1. 编程语言与基础能力：熟悉 C、C++、Python 编程语言，具备扎实的数据结构与算法基础，
2. AI 编译与高性能计算：熟悉 NPU、GPU 等异构计算架构的基础原理；掌握 MLIR 的基本实现逻辑，具备 tvm
框架的实际应用经验；了解 MLIR Dialect 设计原理；熟悉 onnx runtime 和 TensorRT 的推理部署流程，可实现
模型的高效落地；了解算子融合、算子调度策略（如循环展开、分块）对性能的影响
3. CUDA 开发能力：了解 CUDA 编程模型及核心语法，掌握基础计算优化策略，能够借助性能分析工具 nsys 定
位计算和访存瓶颈，进一步代码性能调优
4. 机器学习框架应用：熟练使用 PyTorch 框架进行模型开发，可独立设计并实现主流深度学习模型架构，具备模
型训练与调试的完整经验
5. 操作系统与工具链：熟悉 Linux 操作系统基本特性及常用命令，熟练运用 git、gdb、vim、tmux 等开发工具
姓名：温汉铮
出生年月：2001.01.26
专业：计算机技术
邮箱：whz191002@163.com
联系电话：15600335911
科研竞赛< < <
1. 参与导师多个国家级项目并完成一篇 SCI 论文，并且参与发表国家级软件著作*3、国家专利*4
2. 国家励志奖学金、学业优秀三等奖学金；获得多个程序设计竞赛奖和大学生建模竞赛奖
个人评价< < <
1. 具备良好的表达能力和沟通协作能力，踏实肯干，能够承受较强的工作压力
2. 严谨细致，独立思考，有强烈责任心和严谨工作作风
3. 良好的协作沟通能力和团队合作精神，积极思考
4. 有责任心、做事认真负责、适应能力较强、 喜欢团队合作，能快速融入团队生活
科研竞赛< < <
1. 参与导师多个国家级项目并完成一篇 SCI 论文，并且参与发表国家级软件著作*3、国家专利*4
2. 国家励志奖学金、学业优秀三等奖学金；获得多个程序设计竞赛奖和大学生建模竞赛奖











#include <stdio.h>
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr){}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr){}
    TreeNode(int x, TreeNode *left, TreeNode *right): val(x), left(left), right(right){}
};
class Solution {
    public:
    
        vector<vector<int>> levelOrder(TreeNode* root) {
            if (root == nullptr) {
                return {};
            }
            queue<TreeNode*> q;
            vector<vector<int>> res;
            q.push(root);
            while (!q.empty()) {
                int sz = q.size();
                vector<int> level;
                for (int i = 0; i < sz; i++) {
                    TreeNode* node = q.front();
                    q.pop();
                    level.push_back(node->val);
                    if (node->left) {
                        q.push(node->left);
                    }
                    if (node->right) {
                        q.push(node->right);
                    }
                   
                }
                res.push_back(level);
            }
            return res;    
        };
};

int main() {
    TreeNode* q0 = new TreeNode(15);
    TreeNode* q1 = new TreeNode(7);  
    TreeNode* q2 = new TreeNode(9);
    TreeNode* q3 = new TreeNode(20, q0, q1);
    TreeNode* q4 = new TreeNode(3, q2, q3);   
    auto solution = Solution();
    auto res = solution.levelOrder(q4);
    for (int j = 0; j <res.size(); j++) {
        auto level = res[j];
        printf("[");
        for (int i = 0; i<level.size(); i++) {
            printf("%d", level[i]);
            if (i != level.size() -1) {printf(",");}
        }
        printf("]");
        if (j != res.size() - 1) {
            
            printf(",");
        }
    }

    return 0;
}